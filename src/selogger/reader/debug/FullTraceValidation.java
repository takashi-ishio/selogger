package selogger.reader.debug;


import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import selogger.EventType;
import selogger.logging.io.BinaryStreamLogger;
import selogger.reader.Event;
import selogger.reader.EventReader;
import selogger.weaver.MethodInfo;
import selogger.reader.DataIdMap;

/**
 * This class is a main class to check the consistency 
 * of ENTRY-EXIT pairs and CALL-CALL_RETURN pairs in an execution trace.
 * This class is also an example implementation representing 
 * the usage of EventReader class.
 */
public class FullTraceValidation {

	/**
	 * Validate a sequence of events 
	 * @param args specify a directory which contains Location ID Files.
	 */
	public static void main(String[] args) {
		long time = System.currentTimeMillis();
		long eventCount = 0;
		try {
			File dir = new File(args[0]);
			FullTraceValidation validator = new FullTraceValidation(args[0]);
			EventReader reader = new EventReader(dir, validator.locationIdMap);
			reader.setProcessParams(true);
			int paramEventCount = 0;
			for (Event e = reader.nextEvent(); e != null; e = reader.nextEvent()) {
				// Print a "." for each file
				if (e.getEventId() % BinaryStreamLogger.MAX_EVENTS_PER_FILE == 0) {
					System.out.print(".");
				}
				
				// Count an event
				if (e.getParams() != null) {
					paramEventCount += e.getParams().length;
					assert e.getParamCount() == e.getParams().length;
				}
				eventCount++;
				
				// Process the event
				validator.processNextEvent(e);
			}
			System.out.println();
			System.out.println(paramEventCount);
			validator.reportResult();
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println("Events processed: " + eventCount);
		System.out.println("Time consumed: " + (System.currentTimeMillis() - time));
	}
	
	private ArrayList<ThreadState> threadState;
	private CallStackSet stacks;
	private DataIdMap locationIdMap;
	
	/**
	 * Create an instance for trace validation.
	 * @param dir is the directory containing files generated by the weaver.
	 * @throws IOException 
	 */
	public FullTraceValidation(String dir) throws IOException {
		threadState = new ArrayList<ThreadState>();
		stacks = new CallStackSet();
		locationIdMap = new DataIdMap(new File(dir));
	}
	
	/**
	 * 
	 * @param e
	 */
	public void processNextEvent(Event e) {
		// Check entry-exit separately from other events.
		if (e.getEventType() == EventType.METHOD_ENTRY ||
				e.getEventType() == EventType.METHOD_NORMAL_EXIT ||
				e.getEventType() == EventType.METHOD_EXCEPTIONAL_EXIT) {
			
			MethodInfo m = e.getMethodEntry();
			if (e.getEventType() == EventType.METHOD_ENTRY) {
				stacks.processEnter(e.getEventId(), e.getThreadId(), m);
			} else {
				stacks.processExit(e.getEventId(), e.getThreadId(), m);
			}
		}
		
		// Check call-return, entry-exit events.
		// Call ThreadState.processEvent for a thread.
		int thread = e.getThreadId();
		while (threadState.size() <= thread) {
			threadState.add(null);
		}
		if (threadState.get(thread) != null) {
			ThreadState s = threadState.get(thread);
			s.processEvent(e);
		} else {
			ThreadState s = new ThreadState();
			threadState.set(thread, s);
			s.processEvent(e);
		}
	}
	
	
	/**
	 * Print the final state of the call stacks.
	 * Method signatures are printed if ENTRY-EXIT and 
	 * CALL-CALL_RETURN are inconsistent.
	 */
	public void reportResult() {
		for (CallStack c: stacks) {
			int entryCount = c.size();
			System.out.println("Thread " + c.getThreadId());
			System.out.print("  Method signature: ");
			for (int i=0; i<entryCount; ++i) {
				System.out.print(c.getMethodOnStack(i));
				System.out.print("  ");
			}
			System.out.println();
		}
	}
	

}
